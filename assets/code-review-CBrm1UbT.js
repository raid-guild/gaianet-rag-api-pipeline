import{u as r,j as e}from"./index-CnErcBSh.js";const s={title:"In-depth Source Code Review",description:"undefined"};function a(n){const i={a:"a",aside:"aside",code:"code",div:"div",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...r(),...n.components};return e.jsxs(e.Fragment,{children:[e.jsx(i.header,{children:e.jsxs(i.h1,{id:"in-depth-source-code-review",children:["In-depth Source Code Review",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#in-depth-source-code-review",children:e.jsx(i.div,{"data-autolink-icon":!0})})]})}),`
`,e.jsx(i.p,{children:"This document walks through the different modules that comprise the RAG (Retrieval-Augmented Generation) API Pipeline architecture. The system is designed to extract, preprocess, parse, and store data streams from an API source, then create a vector embeddings knowledge base that can be queried using natural language processing and/or hybrid search techniques. Data from each pipeline stage is serialized using a JSON Lines format for easy caching and reuse."}),`
`,e.jsxs(i.h2,{id:"data-flow-overview",children:["Data Flow Overview",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#data-flow-overview",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsx("iframe",{src:"https://mermaid.live/view#pako:eNplVF1vozAQ_CuWXy8l4SPQoNNJiZqmVZM2Ou7pnD44eAOogJEx7eWa_PdbQ0lzqSUke3Z2Zz22eaexFEBDmihepeTXbFMSHHWz7YBpprZ7DWxDP2bkG1lznb7x_YY-d2Qz1iu2zirIsxLIipfZDmr9TK6ufhxsyyYKuDiQ6ZJN1_dLyQWos9SniD1VUGKIRBXEfZZzyvqkTpdt0MGSCZSguIYDiVYsko2KgRS98GdGtGozXMyoNVf6QH5OFww_0rd7RjawYXstWyos_jBjD6V8y0EkQGa8Pqc_zD7YTs_GAl0YSnFhJIYiUK-g0Eqj0263Bf7zcblcMfxIgaeSn5s0ve9cujeZZ4H5is2LLQiRlcmXrItmZgs2k1wJJWVBFhK1S16ib6ai2Up_2h27d2NsjcgOuG4UEOilDp8b6tgfZvhIjkpe1anUXzgXy8UjW_CMP4ImayW1jGVOcPEm1cvzRQL5btpbPHbw3S27a5LE7PiWx4C9WyhtLtYXyZP_S0hOPrRG2wxFY6jrc_cddsM1J5E5znPcZfM_2tiVt4eWxX0Ua9IBLUAVPBP4jN4NvKE6hQI2NMSp4OplQzflEXm80TLalzENtWpgQJVskpSGO57XuGoqgRf6JuPYcXGBzkWGPZ3AvH1ENHynel-1zzerNQrEstxlicEblSOcal3V4XBowlaS6bTZWrEshnUmUnwN6evEH_qOf80dF_zA5WPXFfHWnlzvHM_eiWBkO5wejwMKrf6q-1e0v4wBrXj5G2_SqSlcG-U_NPS8seU7I8_3XMcbjQN_PKB7GrquhdBoPPa8IJg49gQL_20rjKxrN_B8Z-Lb2Ebg-sHxHxjOZcQ",width:"100%",height:"900px"}),`
`,e.jsxs(i.ol,{children:[`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"API Loader"}),": Generates an Airbyte declarative stream manifest using the input API pipeline manifest and the API OpenAPI spec."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"Data Extraction"}),": PyAirbyte uses the source manifest to create individual data streams for each specified API endpoint. Raw data is then cached using Airbyte DuckDB for efficient API data retrieval."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"Processing & Transformation"}),": Pathway handles real-time preprocessing of data streams, transforming raw data into a usable format. Endpoint text fields specified in the API pipeline manifest are joined together into a ",e.jsx(i.code,{children:"content"})," field, while the remaining fields are stored in a JSON ",e.jsx(i.code,{children:"metadata"})," object."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"Data Normalization"}),": Preprocessed data streams are joined together into a single normalized stream."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"Data Partitioning & Chunking"}),": Normalized data records are then partitioned and chunked."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"Vector Embeddings Generation"}),": The pipeline connects to an LLM provider to use a hosted embedding model for generating vector embeddings from chunked data records."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"Loading Knowledge Base Snapshot"}),": The resulting QdrantDB collection snapshot can be imported into a Gaia node, allowing the LLM model to use the domain knowledge for providing RAG-based answers to end users."]}),`
`]}),`
`,e.jsxs(i.h2,{id:"pipeline-components",children:["Pipeline Components",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#pipeline-components",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.h3,{id:"cli-entrypoint-source",children:["CLI Entrypoint (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/run.py",children:"Source"}),")",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#cli-entrypoint-source",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.p,{children:["The entrypoint module uses ",e.jsx(i.a,{href:"https://click.palletsprojects.com/en/8.1.x/#documentation",children:"Click"})," to define CLI commands that execute specific pipeline stages. Check the ",e.jsx(i.a,{href:"/cli/reference",children:"CLI reference"})," for details on available commands and arguments."]}),`
`,e.jsxs(i.h3,{id:"api-loader-source",children:["API Loader (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/loader.py",children:"Source"}),")",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#api-loader-source",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsx(i.p,{children:"Uses the input API pipeline manifest and API OpenAPI spec to generate/load an Airbyte declarative stream manifest for initiating the input data streams."}),`
`,e.jsx(i.p,{children:"Input Parameters:"}),`
`,e.jsxs(i.ul,{children:[`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"API Pipeline Manifest"}),": A YAML file defining configuration settings and API endpoints for extraction. The ",e.jsx(i.a,{href:"/manifest-definition",children:"Defining the API Pipeline Manifest"})," reference provides details on creating a new manifest for your target API."]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"OpenAPI Spec"}),": YAML file containing the OpenAPI specification for the API source."]}),`
`]}),`
`,e.jsx(i.p,{children:"Output:"}),`
`,e.jsxs(i.ul,{children:[`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"api_name"}),": API Pipeline ID"]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"api_parameters"}),": Input parameter values for injection into the Airbyte API connector"]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"source_manifest"}),": Generated source manifest (dict serialized)"]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"endpoint_text_fields"}),": Text fields per API endpoint"]}),`
`,e.jsxs(i.li,{children:[e.jsx(i.strong,{children:"chunking_params"}),": Chunking parameters for the data chunking stage"]}),`
`]}),`
`,e.jsxs(i.h3,{id:"input-module-source",children:["Input Module (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/input.py",children:"Source"}),")",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#input-module-source",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.p,{children:["Uses Pathway and PyAirbyte to implement the ",e.jsx(i.code,{children:"AirbyteAPIConnector"})," (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/io/airbyte/api_connector.py",children:"Source"}),"). The input module uses this custom connector with ",e.jsx(i.code,{children:"api_parameters"})," to create data stream tables for each API endpoint in ",e.jsx(i.code,{children:"source_manifest"}),"."]}),`
`,e.jsxs(i.h3,{id:"rag-pipeline-source",children:["RAG Pipeline (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/pipeline.py",children:"Source"}),")",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#rag-pipeline-source",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsx(i.p,{children:"Receives input data streams and executes the following processing steps:"}),`
`,e.jsxs(i.ol,{children:[`
`,e.jsxs(i.li,{children:[`
`,e.jsxs(i.p,{children:[e.jsx(i.strong,{children:"Preprocessing"})," (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/preprocessing.py",children:"Source"}),"): Transforms raw data streams into a ",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/schema/pipeline.py#L6",children:"unified data schema"})," using specified ",e.jsx(i.code,{children:"endpoint_text_fields"}),"."]}),`
`]}),`
`,e.jsxs(i.li,{children:[`
`,e.jsxs(i.p,{children:[e.jsx(i.strong,{children:"Normalization"}),": Joins preprocessed data into a single normalized stream table."]}),`
`]}),`
`,e.jsxs(i.li,{children:[`
`,e.jsxs(i.p,{children:[e.jsx(i.strong,{children:"Data Partitioning and Chunking"})," (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/chunking.py",children:"Source"}),"): Receives the normalized data stream and ",e.jsx(i.code,{children:"chunking_params"})," to apply data partition and chunking using the ",e.jsx(i.code,{children:"CustomParseUnstructured"})," (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/processor/parser.py",children:"Source"}),") UDF (Pathway User-defined Function)."]}),`
`]}),`
`,e.jsxs(i.li,{children:[`
`,e.jsxs(i.p,{children:[e.jsx(i.strong,{children:"Feature Embeddings"})," (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/embeddings.py",children:"Source"}),"): The ",e.jsx(i.code,{children:"CustomLiteLLMEmbedder"})," (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/processor/embedder.py",children:"Source"}),") integrates ",e.jsx(i.code,{children:"litellm"})," and ",e.jsx(i.code,{children:"ollama"})," libraries to connect to the selected LLM provider for generating vector embeddings."]}),`
`]}),`
`]}),`
`,e.jsx(i.aside,{"data-callout":"info",children:e.jsx(i.p,{children:`NOTICE:
For pipeline execution on consumer hardware, we recommend using Ollama as a more lightweight LLM provider for vector embeddings generation.`})}),`
`,e.jsxs(i.h3,{id:"output-module-source",children:["Output Module (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/output.py",children:"Source"}),")",e.jsx(i.a,{"aria-hidden":"true",tabIndex:"-1",href:"#output-module-source",children:e.jsx(i.div,{"data-autolink-icon":!0})})]}),`
`,e.jsxs(i.p,{children:["Uses the ",e.jsx(i.code,{children:"qdrant_client"})," library to implement the ",e.jsx(i.code,{children:"QdrantDBVectorStore"})," (",e.jsx(i.a,{href:"https://github.com/raid-guild/gaianet-rag-api-pipeline/blob/main/gaianet_rag_api_pipeline/io/qdrant.py",children:"Source"}),"). It connects to a ",e.jsx(i.a,{href:"https://pathway.com/developers/user-guide/connect/connectors/python-output-connectors",children:"Pathway output connector"})," to read records from the embeddings stream, store vector embeddings and attached metadata in a Qdrant DB collection, and generate and download a knowledge base snapshot."]})]})}function d(n={}){const{wrapper:i}={...r(),...n.components};return i?e.jsx(i,{...n,children:e.jsx(a,{...n})}):a(n)}export{d as default,s as frontmatter};
